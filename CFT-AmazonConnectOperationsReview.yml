# CloudFormation template for Amazon Connect Operational Review
AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template for Amazon Connect Operational Review with embedded Lambda code. Please use us-east-1 to import this template file.'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Amazon Connect Operational Review Configuration"
        Parameters:
          - AmazonConnectInstanceARN
          - AmazonConnectCloudWatchLogGroup
          - AmazonS3ForReports
    ParameterLabels:
      AmazonConnectInstanceARN:
        default: "Amazon Connnect Instance ARN"
      AmazonConnectCloudWatchLogGroup:
        default: "Amazon Connect CloudWatch LogGroup"
      AmazonS3ForReports:
        default: "Amazon S3 bucket name"
        
Parameters:
  AmazonConnectInstanceARN:
    Type: String
    Description: 'The ARN of your Amazon Connect instance for this review. Example: arn:aws:connect:<region>:<account-id>:instance/<resource-id>'
  
  AmazonConnectCloudWatchLogGroup:
    Type: String
    Description: 'The ARN of your Amazon Connect instance CloudWatch Log Group resource. Example: /aws/connect/connect-instance-name'
  
  AmazonS3ForReports:
    Type: String
    Description: 'Existing S3 Bucket name for uploading Operational review reports'
    MinLength: 3
    MaxLength: 63
    ConstraintDescription: 'Must be a valid S3 bucket name'

Resources:
  # IAM Role for Lambda execution with required permissions
  AmazonConnectOperationalReviewLambdaExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonConnectReadOnlyAccess
        - arn:aws:iam::aws:policy/AWSCloudTrail_ReadOnlyAccess
        - arn:aws:iam::aws:policy/ServiceQuotasReadOnlyAccess
        - arn:aws:iam::aws:policy/CloudWatchReadOnlyAccess
        
      Policies:
      - PolicyDocument:
          Version: "2012-10-17"
          Statement:
          - Resource: "*"
            Action: "mobiletargeting:PhoneNumberValidate"
            Effect: "Allow"
            Sid: "VisualEditor0"
        PolicyName: "PinpointPhoneNumberValidateReadOnlyAccess"
      - PolicyDocument:
          Version: "2012-10-17"
          Statement:
          - Resource: !Sub 'arn:aws:s3:::${AmazonS3ForReports}/*'
            Action: "s3:PutObject"
            Effect: "Allow"
            Sid: "VisualEditor0"
        PolicyName: "PutObjectToS3-Review"

  # Lambda function with embedded code
  LambdaFunctionAmazonConnectOperationalReviewauto:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "amazonConnectOperationalReview-auto"
      Handler: "index.lambda_handler"
      Role: !GetAtt AmazonConnectOperationalReviewLambdaExecutionRole.Arn
      Runtime: python3.13
      Timeout: 900
      MemorySize: 256
      Environment:
        Variables:
          CONNECT_INSTANCE_ARN: !Ref AmazonConnectInstanceARN
          CONNECT_CW_LOG_GROUP: !Ref AmazonConnectCloudWatchLogGroup
          S3_REPORTING_BUCKET: !Ref AmazonS3ForReports
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import os
          import sys
          import traceback
          from botocore.exceptions import ClientError
          from html import escape
          from datetime import datetime
          from datetime import datetime, timedelta
          from collections import defaultdict
          import statistics
          import time
          from collections import Counter
          from typing import Dict, List, Optional, Any, Tuple

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Format the datetime object into a string including the timezone name
          currentDateAndTime = datetime.now()
          datetime_string = currentDateAndTime.strftime("%Y-%m-%d %H:%M:%S %Z%z")

          # Intialize (log group, AWS region, days back)
          #log_group = f'/aws/connect/ganesh-test-us-east-1'

          # Initialize Connect client
          connect_client = boto3.client('connect')

          # Initialize S3 client
          s3_client = boto3.client('s3')  

          # Initialize CloudWatch client
          cloudwatch_client = boto3.client('cloudwatch')

          # Initialize CloudWatch logs client
          logs_client = boto3.client('logs')

          # Initialize CloudTrail client
          cloudtrail_client = boto3.client('cloudtrail')    

          # Initialize CloudWatch logs client
          pinpoint_client = boto3.client('pinpoint')

          """Parse instance_id and aws_region from Amazon Connect instance ARN"""
          def parse_connect_instance_arn(instance_arn):
              """
                  ARN format: arn:aws:connect:region:account-id:instance/instance-id
              
              Args:
                  instance_arn (str): Amazon Connect instance ARN
              
              Returns:
                  dict: Contains instance_id, aws_region, account_id, and other components
              """
              
              if not instance_arn or not isinstance(instance_arn, str):
                  raise ValueError("Invalid ARN provided in envonment variable - CONNECT_INSTANCE_ARN")
              
              # Split ARN by colons
              arn_parts = instance_arn.split(':')
              
              if len(arn_parts) < 6 or arn_parts[0] != 'arn' or arn_parts[2] != 'connect':
                  raise ValueError(f"Invalid Connect instance ARN format: {instance_arn}")
              
              # Extract components
              aws_region = arn_parts[3]
              account_id = arn_parts[4]
              resource_part = arn_parts[5]  # instance/instance-id
              
              # Extract instance ID from resource part
              if not resource_part.startswith('instance/'):
                  raise ValueError(f"Invalid resource type in ARN: {resource_part}")
              
              instance_id = resource_part.split('/', 1)[1]
              
              return {
                  'instance_id': instance_id,
                  'aws_region': aws_region,
                  'account_id': account_id,
                  'service': arn_parts[2],
                  'partition': arn_parts[1],
                  'resource_type': 'instance',
                  'full_arn': instance_arn
              }

          """Get various Service Quota elements for Amazon Connect"""
          def get_connect_service_quotas():
              """Retrieve all Amazon Connect service quotas"""
              try:
                  service_quotas = boto3.client('service-quotas')
                  quotas = []
                  
                  # Use paginator to get all quotas
                  paginator = service_quotas.get_paginator('list_service_quotas')
                  
                  for page in paginator.paginate(ServiceCode='connect'):
                      quotas.extend(page['Quotas'])
                  
                  return quotas
              
              except ClientError as e:
                  logger.error(f"Error retrieving service quotas: {e}")
                  return []

          def get_color_by_percentage(percentage):
              """Return color code based on percentage value"""
              if percentage >= 98:
                  return "#FF0000"  # Red - Critical
              elif percentage >= 80:
                  return "#FFA500"  # Orange - Warning  
              #elif percentage >= 50:
              #    return "#FFFF00"  # Yellow - Caution
              else:
                  return "#00FF00"  # Green - Normal

          """Get Current utilization for Amazon Connect"""
          def current_utilization (instance_id, metric_name):
             
              try:
                  matched_value = metric_name
                  if matched_value == "ContactFlows":
                      # List all contact flows
                          response = connect_client.list_contact_flows(InstanceId=instance_id)
                          metric_usage = len(response['ContactFlowSummaryList'])
                  
                  # Get the current number of Users
                  elif matched_value == "Users":
                      # List all users
                          response = connect_client.list_users(InstanceId=instance_id)
                          metric_usage = len(response['UserSummaryList'])
                  
                  # Get the current number of Queues
                  elif matched_value == "Queues":
                      # List all queues
                          response = connect_client.list_queues(InstanceId=instance_id)
                          metric_usage = len(response['QueueSummaryList'])

                  elif matched_value == "RoutingProfiles":
                      # List all routing profiles
                          response = connect_client.list_routing_profiles(InstanceId=instance_id)
                          metric_usage = len(response['RoutingProfileSummaryList'])
                  
                  elif matched_value == "SecurityProfiles":
                      # List all security profiles
                          response = connect_client.list_security_profiles(InstanceId=instance_id)
                          metric_usage = len(response['SecurityProfileSummaryList'])

                  elif matched_value == "HoursOfOperation":
                      # List all hours of operation
                          response = connect_client.list_hours_of_operations(InstanceId=instance_id)
                          metric_usage = len(response['HoursOfOperationSummaryList'])
                  
                  elif matched_value == "Prompts":
                      # List all prompts
                          response = connect_client.list_prompts(InstanceId=instance_id)
                          metric_usage = len(response['PromptSummaryList'])

                  elif matched_value == "LexBotsV1":
                      # List all lex bots
                          response = connect_client.list_bots(InstanceId=instance_id, LexVersion='V1')
                          metric_usage = len(response['LexBots'])
                  
                  elif matched_value == "LexBotsV2":
                      # List all lex bots
                          response = connect_client.list_bots(InstanceId=instance_id, LexVersion='V2')
                          metric_usage = len(response['LexBots'])
                  
                  elif matched_value == "PhoneNumbers":
                      # List all phone numbers
                          response = connect_client.list_phone_numbers(InstanceId=instance_id)
                          metric_usage = len(response['PhoneNumberSummaryList'])

                  elif matched_value == "AgentStatuses":
                      # List all agent statuses
                          response = connect_client.list_agent_statuses(InstanceId=instance_id)
                          metric_usage = len(response['AgentStatusSummaryList'])

                  elif matched_value == "ContactFlowModules":
                      # List all contact flow modules
                          response = connect_client.list_contact_flow_modules(InstanceId=instance_id)
                          metric_usage = len(response['ContactFlowModulesSummaryList'])
                  
                  elif matched_value == "QuickConnects":
                      # List all quick connects
                          response = connect_client.list_quick_connects(InstanceId=instance_id)
                          metric_usage = len(response['QuickConnectSummaryList'])
                  
                  else:
                  # Handle unexpected metric_name values
                      error = f"Unknown metric name: {metric_name}"
                      logger.warning(error)
                      return error

                  logger.debug(f"Metric {matched_value} usage : {metric_usage}")

                  return metric_usage

              except Exception as e:
                  logger.error(f"AWS Client Error: {e}")
                  #print(traceback.format_exc())
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': 'AWS API Error',
                          'message': str(e)
                      })
                  }
              
              except Exception as e:
                  logger.error(f"Unexpected error: {e}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': 'Internal server error',
                          'message': str(e)
                      })
                  }

          """Service Quota value for those service quota"""
          def get_connect_service_quota(instance_id_arn, quota_code):
              """Retrieve all Amazon Connect service quotas"""
              try:
                 
                  response = quota_client.get_service_quota(
                  ServiceCode='connect',
                  QuotaCode=quota_code,
                  ContextId=instance_id_arn # Optional, for resource-level quotas
                  )
                  
                  quota_value = response['Quota']['Value']
                  quota_unit = response['Quota']['Unit']

                  logger.debug(f"For Amazon Connect quota_code {quota_code} value is {quota_value} with unit {quota_unit}")

                  return quota_value
              
              except ClientError as e:
                  logger.error(f"Error retrieving service quotas: {e}")
                  return []

          """class for segregating JSON data."""
          class JSONSegregator:
              
              def __init__(self, data: List[Dict[str, Any]]):
                  self.data = data
              
              def by_key(self, key: str, include_missing: bool = True) -> Dict[str, List[Dict]]:
                  """Segregate by a single key."""
                  result = defaultdict(list)
                  
                  for item in self.data:
                      if key in item:
                          value = str(item[key])  # Convert to string for consistent keys
                          result[value].append(item)
                      elif include_missing:
                          result['_missing'].append(item)
                  
                  return dict(result)
              
              def by_value_range(self, key: str, ranges: List[tuple]) -> Dict[str, List[Dict]]:
                  """Segregate by value ranges."""
                  result = defaultdict(list)
                  
                  for item in self.data:
                      if key in item:
                          value = item[key]
                          assigned = False
                          
                          for range_name, min_val, max_val in ranges:
                              if min_val <= value < max_val:
                                  result[range_name].append(item)
                                  assigned = True
                                  break
                          
                          if not assigned:
                              result['_out_of_range'].append(item)
                      else:
                          result['_missing_key'].append(item)
                  
                  return dict(result)
              
              def by_custom_function(self, func) -> Dict[str, List[Dict]]:
                  """Segregate using custom function."""
                  result = defaultdict(list)
                  
                  for item in self.data:
                      try:
                          group_key = func(item)
                          result[str(group_key)].append(item)
                      except Exception as e:
                          result[f'_error_{type(e).__name__}'].append(item)
                  
                  return dict(result)

          """Segregate data based on a specific JSON element/key."""
          def segregate_by_json_element(data, key):
              """
              Args:
                  data (list): List of dictionaries (JSON objects)
                  key (str): The key to segregate by
              
              Returns:
                  dict: Dictionary with segregated data
              """
              segregated = defaultdict(list)
              
              for item in data:
                  if key in item:
                      value = item[key]
                      segregated[value].append(item)
                  else:
                      # Handle items without the key
                      segregated['_missing_key'].append(item)
              
              return dict(segregated)

          """Segregate data based on multiple JSON elements."""
          def segregate_by_multiple_criteria(data, criteria):
              """
              Args:
                  data (list): List of dictionaries
                  criteria (list): List of keys to create composite grouping
              
              Returns:
                  dict: Dictionary with segregated data using composite keys
              """
              segregated = defaultdict(list)
              
              for item in data:
                  # Create composite key from multiple criteria
                  key_parts = []
                  for criterion in criteria:
                      if criterion in item:
                          key_parts.append(str(item[criterion]))
                      else:
                          key_parts.append('_missing')
                  
                  composite_key = ' | '.join(key_parts)
                  segregated[composite_key].append(item)
              
              return dict(segregated)
          """Comprehensive analyze CloudWatch Metrics - Concurrent Calls"""
          def summarize_concurrent_calls(instance_id, days_back):
              html_content = f"<b>Summarize concurrent calls for Amazon Connect over the last {days_back} days</b><br>"
              
              # Calculate time range for last 2 weeks
              end_time = datetime.utcnow() +  timedelta(days=1)
              start_time = end_time - timedelta(days=1)
              
              logger.debug(f"\n Retrieving concurrent calls data from {start_time.date()} to {end_time.date()}")
              
              try:
                  # Get concurrent calls metrics
                  response = cloudwatch_client.get_metric_statistics(
                      Namespace='AWS/Connect',
                      MetricName='ConcurrentCalls',
                      Dimensions=[
                          {'Name': 'InstanceId', 'Value': instance_id}
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=3600,  # 1-hour periods for detailed analysis
                      Statistics=['Average', 'Maximum', 'Minimum']
                  )
                  
                  # Process data by day
                  daily_stats = defaultdict(lambda: {'hourly_avg': [], 'hourly_max': [], 'hourly_min': []})
                  
                  for datapoint in response['Datapoints']:
                      date = datapoint['Timestamp'].date()
                      daily_stats[date]['hourly_avg'].append(datapoint['Average'])
                      daily_stats[date]['hourly_max'].append(datapoint['Maximum'])
                      daily_stats[date]['hourly_min'].append(datapoint['Minimum'])
                  
                  # Calculate overall statistics
                  all_averages = []
                  all_maximums = []
                  all_minimums = []
                  
                  logger.debug(f"\n{'='*60}")
                  logger.debug(f"CONCURRENT CALLS SUMMARY - LAST 2 WEEKS")
                  logger.debug(f"Instance ID: {instance_id}")
                  logger.debug(f"{'='*60}")
                  
                  # Daily breakdown
                  for date in sorted(daily_stats.keys()):
                      stats = daily_stats[date]
                      
                      daily_avg = sum(stats['hourly_avg']) / len(stats['hourly_avg'])
                      daily_max = max(stats['hourly_max'])
                      daily_min = min(stats['hourly_min'])
                      
                      all_averages.extend(stats['hourly_avg'])
                      all_maximums.extend(stats['hourly_max'])
                      all_minimums.extend(stats['hourly_min'])
                      
                      logger.debug(f"\n{date.strftime('%A, %B %d, %Y')}:")
                      logger.debug(f"  Daily Average: {daily_avg:.2f} calls")
                      logger.debug(f"  Peak (Maximum): {daily_max:.0f} calls")
                      logger.debug(f"  Lowest (Minimum): {daily_min:.0f} calls")
                      logger.debug(f"  Data points: {len(stats['hourly_avg'])} hours")
                  
                  # Overall 2-week summary
                  if all_averages:
                      overall_avg = sum(all_averages) / len(all_averages)
                      overall_max = max(all_maximums)
                      overall_min = min(all_minimums)
                      
                      logger.debug(f"\n{'='*60}")
                      logger.debug(f"OVERALL 2-WEEK SUMMARY")
                      logger.debug(f"{'='*60}")
                      html_content += f"<br>Period Average: {overall_avg:.2f} concurrent calls"
                      html_content += f"<br>Absolute Peak: {overall_max:.0f} concurrent calls"
                      html_content += f"<br>Absolute Minimum: {overall_min:.0f} concurrent calls"
                      html_content += f"<br>Total data points: {len(all_averages)} hours"
                      
                      # Additional insights
                      html_content += f"<br><br>INSIGHTS:"
                      html_content += f"<br>- Average daily variation: {(overall_max - overall_min):.0f} calls"
                      html_content += f"<br>- Peak utilization was {(overall_max / overall_avg - 1) * 100:.1f}% above average"
                      
                  else:
                      html_content += f"<br>No data available for the specified time period."
                      logger.debug("\nNo data available for the specified time period.")
                      
              except Exception as e:
                  logger.error(f"Error retrieving metrics: {str(e)}")
                  html_content = f"\nError retrieving metrics: {str(e)}"

              return html_content

          """Comprehensive analyze of missed calls summary for Amazon Connect"""
          def summarize_missed_calls(instance_id, days_back):
              html_content = f"<b>Summarize missed calls for Amazon Connect over the last {days_back} days</b><br>"

              # Calculate time range for last 2 weeks
              end_time = datetime.utcnow()
              start_time = end_time - timedelta(days_back)
              
              logger.debug(f"Retrieving missed calls data from {start_time.date()} to {end_time.date()}")
              logger.debug(f"Instance ID: {instance_id}")
              
              try:
                  # Get missed calls metrics with daily granularity
                  response = cloudwatch_client.get_metric_statistics(
                      Namespace='AWS/Connect',
                      MetricName='MissedCalls',
                      Dimensions=[
                          {'Name': 'InstanceId', 'Value': instance_id},
                          {'Name': 'MetricGroup', 'Value': 'VoiceCalls'}
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=86400,  # Daily statistics (24 hours)
                      Statistics=['Sum']
                  )
                  
                  # Process daily data
                  daily_data = []
                  total_missed_calls = 0
                  
                  for datapoint in sorted(response['Datapoints'], key=lambda x: x['Timestamp']):
                      date = datapoint['Timestamp'].date()
                      missed_calls = int(datapoint['Sum'])
                      total_missed_calls += missed_calls
                      daily_data.append((date, missed_calls))
                  
                  logger.debug(f"\n{'='*60}")
                  logger.debug(f"MISSED CALLS SUMMARY - LAST 2 WEEKS")
                  logger.debug(f"{'='*60}")
                  
                  # Daily breakdown
                  logger.debug(f"\nDAILY BREAKDOWN:")
                  logger.debug(f"{'-'*40}")
                  for date, count in daily_data:
                      day_name = date.strftime('%A')
                      logger.debug(f"{date} ({day_name}): {count:,} missed calls")
                  
                  # Calculate statistics
                  if daily_data:
                      missed_calls_counts = [count for _, count in daily_data]
                      daily_average = statistics.mean(missed_calls_counts)
                      daily_median = statistics.median(missed_calls_counts)
                      max_missed = max(missed_calls_counts)
                      min_missed = min(missed_calls_counts)
                      
                      # Find peak day
                      peak_day = max(daily_data, key=lambda x: x[1])
                      
                      logger.debug(f"\n{'='*60}")
                      logger.debug(f"SUMMARY STATISTICS")
                      logger.debug(f"{'='*60}")
                      html_content+=f"<br>Total missed calls ({days_back}): {total_missed_calls:,}"
                      html_content+=f"<br>Daily average: {daily_average:.1f} missed calls"
                      html_content+=f"<br>Daily median: {daily_median:.1f} missed calls"
                      html_content+=f"<br>Highest single day: {max_missed:,} missed calls"
                      html_content+=f"<br>Lowest single day: {min_missed:,} missed calls"
                      html_content+=f"<br>Peak day: {peak_day[0]} ({peak_day[0].strftime('%A')}) with {peak_day[1]:,} missed calls"
                      
                      # Weekly comparison
                      week1_data = [count for date, count in daily_data if date < start_time.date() + timedelta(days=7)]
                      week2_data = [count for date, count in daily_data if date >= start_time.date() + timedelta(days=7)]
                      
                      if week1_data and week2_data:
                          week1_total = sum(week1_data)
                          week2_total = sum(week2_data)
                          week1_avg = statistics.mean(week1_data)
                          week2_avg = statistics.mean(week2_data)
                          
                          change_percent = ((week2_total - week1_total) / week1_total) * 100 if week1_total > 0 else 0
                          
                          logger.debug(f"\n{'='*60}")
                          logger.debug(f"WEEKLY COMPARISON")
                          logger.debug(f"{'='*60}")
                          logger.debug(f"Week 1 total: {week1_total:,} missed calls (avg: {week1_avg:.1f}/day)")
                          logger.debug(f"Week 2 total: {week2_total:,} missed calls (avg: {week2_avg:.1f}/day)")
                          logger.debug(f"Week-over-week change: {change_percent:+.1f}%")
                          
                          if change_percent > 10:
                              logger.debug("‚ö†Ô∏è  Significant increase in missed calls detected!")
                          elif change_percent < -10:
                              logger.debug("‚úÖ Significant improvement in missed calls!")
                  
                  else:
                      logger.debug("No missed calls data available for the specified time period.")
                      html_content+=f"<br>No missed calls data available for the specified time period."
                  return html_content
                      
              except Exception as e:
                  logger.error(f"Error retrieving metrics: {str(e)}")
                  html_content+=f"<br>Error retrieving metrics: {str(e)}"

          """Comprehensive analysis of ThrottledCalls for Amazon Connect"""
          def summarize_throttled_calls(instance_id, days_back):
              html_content = f"<b>Summarize throttled calls for Amazon Connect over the last {days_back} days</b><br>"

              # Calculate time range
              end_time = datetime.utcnow()
              start_time = end_time - timedelta(days=days_back)
              
              logger.debug(f"Analyzing ThrottledCalls from {start_time.date()} to {end_time.date()}")
              logger.debug(f"Instance ID: {instance_id}")
              
              try:
                  # Get ThrottledCalls metrics
                  response = cloudwatch_client.get_metric_statistics(
                      Namespace='AWS/Connect',
                      MetricName='ThrottledCalls',
                      Dimensions=[
                          {'Name': 'InstanceId', 'Value': instance_id},
                          {'Name': 'MetricGroup', 'Value': 'VoiceCalls'}
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=3600,  # 1-hour intervals
                      Statistics=['Sum', 'Maximum']
                  )
                  
                  datapoints = response['Datapoints']
                  
                  if not datapoints:
                      logger.debug("‚úÖ No throttled calls found in the specified time period!")
                      logger.debug("This indicates your instance is operating within capacity limits.")
                      html_content+=f"<br>No throttled calls found in the specified time period!"
                      html_content+=f"<br>Your instance is operating well within capacity limits"
                      return html_content
                  
                  # Sort datapoints by timestamp
                  sorted_data = sorted(datapoints, key=lambda x: x['Timestamp'])
                  
                  logger.debug(f"\n{'='*70}")
                  logger.debug(f"THROTTLED CALLS ANALYSIS - LAST {days_back} DAYS")
                  logger.debug(f"{'='*70}")
                  
                  # Calculate overall statistics
                  total_throttled = sum(int(dp['Sum']) for dp in sorted_data)
                  hourly_counts = [int(dp['Sum']) for dp in sorted_data]
                  max_hourly = max(hourly_counts)
                  avg_hourly = statistics.mean(hourly_counts) if hourly_counts else 0
                  
                  logger.debug(f"\nOVERALL STATISTICS:")
                  logger.debug(f"  Total throttled calls: {total_throttled:,}")
                  logger.debug(f"  Average per hour: {avg_hourly:.2f}")
                  logger.debug(f"  Maximum in single hour: {max_hourly:,}")
                  logger.debug(f"  Hours with throttling: {len([c for c in hourly_counts if c > 0])}")
                  logger.debug(f"  Total hours analyzed: {len(hourly_counts)}")
                  
                  # Severity assessment
                  logger.debug(f"\nSEVERITY ASSESSMENT:")
                  if total_throttled == 0:
                      logger.debug("  ‚úÖ EXCELLENT - No throttling detected")
                  elif total_throttled < 10:
                      logger.debug("  ‚ö†Ô∏è  LOW - Minimal throttling (< 10 calls)")
                  elif total_throttled < 100:
                      logger.debug("  ‚ö†Ô∏è  MODERATE - Some throttling detected (< 100 calls)")
                  elif total_throttled < 1000:
                      logger.debug("  ‚ùå HIGH - Significant throttling (< 1000 calls)")
                  else:
                      logger.debug("  üö® CRITICAL - Severe throttling (> 1000 calls)")
                      logger.debug("     IMMEDIATE ACTION REQUIRED!")
                  
                  # Daily breakdown
                  daily_stats = defaultdict(int)
                  for dp in sorted_data:
                      date = dp['Timestamp'].date()
                      daily_stats[date] += int(dp['Sum'])
                  
                  logger.debug(f"\nDAILY BREAKDOWN:")
                  logger.debug(f"{'-'*50}")
                  for date in sorted(daily_stats.keys()):
                      count = daily_stats[date]
                      day_name = date.strftime('%A')
                      status = "üö®" if count > 100 else "‚ö†Ô∏è" if count > 10 else "‚úÖ" if count == 0 else "‚ö†Ô∏è"
                      logger.debug(f"  {date} ({day_name}): {count:,} throttled calls {status}")
                  
                  # Peak hours analysis
                  peak_hours = sorted(sorted_data, key=lambda x: x['Sum'], reverse=True)[:5]
                  if peak_hours and peak_hours[0]['Sum'] > 0:
                      logger.debug(f"\nTOP 5 PEAK THROTTLING HOURS:")
                      logger.debug(f"{'-'*50}")
                      for i, dp in enumerate(peak_hours, 1):
                          if dp['Sum'] > 0:
                              timestamp = dp['Timestamp'].strftime('%Y-%m-%d %H:%M UTC')
                              print(f"  {i}. {timestamp}: {int(dp['Sum']):,} throttled calls")
                  
                  # Recommendations
                  print(f"\n{'='*70}")
                  print(f"RECOMMENDATIONS")
                  print(f"{'='*70}")
                  
                  if total_throttled > 0:
                      logger.debug("üîß IMMEDIATE ACTIONS:")
                      logger.debug("  1. Review current service quotas for your Connect instance")
                      logger.debug("  2. Consider requesting quota increases via AWS Support")
                      logger.debug("  3. Analyze call patterns during peak throttling periods")
                      logger.debug("  4. Implement call queuing or retry mechanisms")
                      
                      logger.debug("\nüìä MONITORING IMPROVEMENTS:")
                      logger.debug("  1. Set up CloudWatch alarms for ThrottledCalls metric")
                      logger.debug("  2. Monitor ConcurrentCalls to predict throttling")
                      logger.debug("  3. Track CallsPerInterval for capacity planning")
                      
                      logger.debug("\n‚ö° CAPACITY OPTIMIZATION:")
                      logger.debug("  1. Distribute call load across multiple instances if possible")
                      logger.debug("  2. Implement intelligent call routing")
                      logger.debug("  3. Consider auto-scaling strategies for peak periods")
                  else:
                      logger.debug("‚úÖ Your instance is operating well within capacity limits!")
                      logger.debug("   Continue monitoring to ensure consistent performance.")
                      html_content+=f"Your instance is operating well within capacity limits"
                      html_content+=f"Continue monitoring to ensure consistent performance."
                  return html_content

              except Exception as e:
                  logger.error(f"‚ùå Error retrieving ThrottledCalls metrics: {str(e)}")
                  html_content+=f"<br>Error retrieving metrics: {str(e)}"
          """Lookup CloudTrail events for Amazon Connect"""
          def lookup_connect_cloudtrail_events(account_id, days_back, aws_region):
              """
               Args:
                  instance_id (str): Connect instance ID (optional)
                  days_back : days back for event lookup
                  region (str): AWS region
              
              Returns:
                  list: Connect CloudTrail events
              """
              end_time = datetime.utcnow()
              start_time = end_time - timedelta(hours=24*days_back)
              
              logger.debug(f"üìÖ Start Time for lookup_connect_cloudtrail_events: {start_time}")
              logger.debug(f"üìÖ End Time for lookup_connect_cloudtrail_events: {end_time}")

              connect_events = []
              
              try:
                  # Lookup attributes for Connect events
                  lookup_attributes = [
                      {
                          'AttributeKey': 'EventSource',
                          'AttributeValue': 'connect.amazonaws.com'
                      }
                  ]
                  
                  # Add instance-specific filter if provided
                 # if instance_id:
                 #     lookup_attributes.append({
                 #         'AttributeKey': 'ResourceName',
                 #         'AttributeValue': instance_id
                 #     })
                  
                  # Lookup events
                  paginator = cloudtrail_client.get_paginator('lookup_events')
                  
                  for page in paginator.paginate(
                      LookupAttributes=lookup_attributes,
                      StartTime=start_time,
                      EndTime=end_time
                  ):
                      for event in page['Events']:
                          # Parse and enrich event data
                          event_data = parse_connect_event(event)
                          if event_data:
                              connect_events.append(event_data)
                  
                  return connect_events
                  
              except ClientError as e:
                  logger.debug(f"Error looking up CloudTrail events: {e}")
                  return []

          """Parse and enrich Connect CloudTrail event"""
          def parse_connect_event(event):
              
              try:
                  cloud_trail_event = json.loads(event.get('CloudTrailEvent', '{}'))
                  
                  # Extract key information
                  event_data = {
                      'eventId': event.get('EventId'),
                      'eventName': event.get('EventName'),
                      'eventTime': event.get('EventTime'),
                      'username': event.get('Username'),
                      'eventSource': cloud_trail_event.get('eventSource'),
                      'awsRegion': cloud_trail_event.get('awsRegion'),
                      'sourceIPAddress': cloud_trail_event.get('sourceIPAddress'),
                      'userAgent': cloud_trail_event.get('userAgent'),
                      'requestId': cloud_trail_event.get('requestID'),
                      'userIdentity': cloud_trail_event.get('userIdentity', {}),
                     # 'requestParameters': cloud_trail_event.get('requestParameters', {}),
                     # 'response_elements': cloud_trail_event.get('responseElements', {}),
                      'errorCode': cloud_trail_event.get('errorCode'),
                      'errorMessage': cloud_trail_event.get('errorMessage')
                  }

                  return event_data
                  
              except Exception as e:
                  print(f"Error parsing event: {e}")
                  return None

          """Comprehensive analysis of Amazon Connect API Throttles"""
          def summarize_amazon_api_throttles(instance_id, account_id, days_back, aws_region):

              html_content = f"<b>Summarize throttled calls for Amazon Connect over the last {days_back} days</b><br>"

              try:
                  # Get events from last days_back days
                  events = lookup_connect_cloudtrail_events(account_id, days_back, aws_region)

                  html_content += f"""<br>Analyzing {len(events)} Amazon Connect events during this time-period."""

                  # Use a defaultdict to store counts for each category
                  category_counts = defaultdict(int)
                  category = ""
                  total_throttled_count = 0

                  # Iterate through the data and count by category
                  for item in events:
                      category = item.get("eventName")

                      if item.get("errorCode") == 'TooManyRequestsException' and item.get("awsRegion") == aws_region:
                          category_counts[category] += 1
                          logger.debug(f"Found {category} and add to this seggregated counts")
                          total_throttled_count += 1

                  ## Summary of the output
                  html_content += f"""<br>Found {total_throttled_count} Amazon Connect events which are being throttled in account - {account_id} and region - {aws_region} <br>"""

                  # Print the segregated counts
                  html_content += f"""<br>
                              <table style="width: 50%">
                              <tr><th>Event Name</th><th>Throttle Count</th></tr>"""

                  for category, count in category_counts.items():
                      html_content += f"""<tr><td>{category}</td><td>{count}</td></tr>"""
                      
                  html_content += f"""</table>"""

                  if total_throttled_count > 0:
                      html_content += f"""<h4>Recommendations</h4>
                      <ul>
                          <li>Review current service quotas for your AWS Account</li>
                          <li>Consider exponental and backoff retry logic</li>
                          <li>Consider requesting quota increases via AWS Support</li>
                          <li>Learn more <a href="https://docs.aws.amazon.com/connect/latest/APIReference/best-practices-connect-apis.html" target="_blank">here</a>.</li>
                      </ul><br>"""
                  return html_content

              except Exception as e:
                  logger.error(f"‚ùå Error retrieving Amazon Connect API throttling metrics: {str(e)}")
                  html_content+=f"<br>Error retrieving Amazon Connect API throttling summary.Check the logs"

          """HTML Report upload to S3 bucket"""
          def upload_string_to_s3(string_data, bucket_name, object_key, content_type):
              s3_client = boto3.client('s3')
              
              try:
                  response = s3_client.put_object(
                      Bucket=bucket_name,
                      Key=object_key,
                      Body=string_data,
                      ContentType=content_type
                  )
                  print(f"Report uploaded successfully to https://{bucket_name}.s3.amazonaws.com/{object_key}. ETag: {response['ETag']}")
                  return True
              except ClientError as e:
                  print(f"Error uploading to S3: {e}")
                  return False

          """Get Connect Instance Details"""
          def describe_connect_to_html(instance_id):
              try:
                  # Describe the instance
                  response = connect_client.describe_instance(InstanceId=instance_id)
                  instance = response['Instance']
                  
                  # Generate HTML
                  html_content = f"""
                  <!DOCTYPE html>
                  <html>
                  <head>
                      <title>Amazon Connect Instance - Operations Review</title>
                      <style>
                          body {{ font-family: Arial, sans-serif; margin: 20px; }}
                          table {{ border-collapse: collapse; width: 100%; }}
                          th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                          th {{ background-color: #f2f2f2; }}
                          .header {{ color: #232F3E; }}
                          .section {{ margin: 20px 0; }}
                      </style>
                  </head>
                  <body>
                      <h1 class="header">Amazon Connect Instance - Operations Review</h1>
                      <div class="section">
                          <p><em>Generated on: {escape(datetime_string)} UTC</em></p>
                      </div>
                      <div class="section">
                          <h2>Amazon Connect Instance Information</h2>
                          <h3>Describe Connect</h3>
                          <table>
                              <tr><th>Instance ID</th><td>{escape(instance.get('Id', 'N/A'))}</td></tr>
                              <tr><th>Instance ARN</th><td>{escape(instance.get('Arn', 'N/A'))}</td></tr>
                              <tr><th>Instance Alias</th><td>{escape(instance.get('InstanceAlias', 'N/A'))}</td></tr>
                              <tr><th>Identity Management Type</th><td>{escape(instance.get('IdentityManagementType', 'N/A'))}</td></tr>
                              <tr><th>Instance Status</th><td>{escape(instance.get('InstanceStatus', 'N/A'))}</td></tr>
                              <tr><th>Service Role</th><td>{escape(instance.get('ServiceRole', 'N/A'))}</td></tr>
                              <tr><th>Created Time</th><td>{escape(str(instance.get('CreatedTime', 'N/A')))}</td></tr>
                          </table>
                      </div>
                  """
                  
                  # Add inbound/outbound calls configuration
                  if 'InboundCallsEnabled' in instance or 'OutboundCallsEnabled' in instance:
                      html_content += """
                      <div class="section">
                          <h3>Call Configuration</h3>
                          <table style="width: 50%">
                      """
                      if 'InboundCallsEnabled' in instance:
                          html_content += f"<tr><th>Inbound Calls Enabled</th><td>{escape(str(instance['InboundCallsEnabled']))}</td></tr>"
                      if 'OutboundCallsEnabled' in instance:
                          html_content += f"<tr><th>Outbound Calls Enabled</th><td>{escape(str(instance['OutboundCallsEnabled']))}</td></tr>"
                      html_content += "</table></div></body></html>"

                      logger.debug(f"\nüîÑ REPLICATION CONFIGURATION:")
                      html_content += """<div class="section">
                          <h3>Replication Configuration</h3>"""

                  # Replication configuration (if available)
                      if 'ReplicationConfiguration' in response:
                          replication = response['ReplicationConfiguration']
                          hasConnectReplica = "yes"
                          html_content += """<table>
                              <tr><th>Replication Region</th><td>{escape(replication.get('ReplicationRegion', 'N/A'))}</td></tr>
                              <tr><th>Replication Status</th><td>{escape(replication.get('ReplicationStatus', 'N/A'))}</td></tr>
                              <tr><th>Replication Status Message</th><td>{escape(replication.get('ReplicationStatusMessage', 'N/A'))}</td></tr>
                          </table>
                          </div>"""

                      else:
                          html_content += """<p>No replication configuration available.</p>"""
                          logger.debug("No replication configuration available.")
                          hasConnectReplica = "no"

                  return html_content
                  
              except Exception as e:
                  return f"<html><body><h1>Error</h1><p>Error describing instance: {escape(str(e))}</p></body></html>"
          """Get all phone numbers for the instance"""
          def get_phone_numbers_with_basic_details(connect_client, instance_id):
              """Get all phone numbers with basic information"""
              
              phone_numbers = []
              
              try:
                  # Use ListPhoneNumbersV2 for accurate type identification
                  paginator = connect_client.get_paginator('list_phone_numbers_v2')
                  
                  for page in paginator.paginate(InstanceId=instance_id):
                      for number_summary in page.get('ListPhoneNumbersSummaryList', []):
                          try:
                              # Get basic information for each phone number
                              detailed_info = connect_client.describe_phone_number(
                                  PhoneNumberId=number_summary['PhoneNumberId']
                              )
                              
                              phone_number_carrier = validate_phone_number_for_connect(number_summary['PhoneNumber'], number_summary['PhoneNumberCountryCode'])['carrier']

                              phone_number_info = {
                                  "phone_number_id": number_summary['PhoneNumberId'],
                                  "phone_number": number_summary['PhoneNumber'],
                                  #'phone_number_arn': number_summary['PhoneNumberArn'],
                                  "phone_number_type": number_summary['PhoneNumberType'],
                                  "phone_number_country_code": number_summary['PhoneNumberCountryCode'],
                                  "phone_number_carrier" : phone_number_carrier
                                  }
                              
                              phone_numbers.append(phone_number_info)
                  
                              logger.debug(f"üìû Phone Number: {number_summary['PhoneNumber']}")
                              logger.debug(f"üìû Phone Number Type: {number_summary['PhoneNumberType']}")
                              logger.debug(f"üìû Phone Number Carrier: {phone_number_carrier}")

                          except Exception as e:
                              logger.error(f"Error getting details for phone number {number_summary['PhoneNumber']}: {str(e)}")
                              phone_numbers.append({
                                  "phone_number_id": number_summary['PhoneNumberId'],
                                  "phone_number": number_summary['PhoneNumber'],
                                  #'phone_number_arn': number_summary['PhoneNumberArn'],
                                  "phone_number_type": number_summary['PhoneNumberType'],
                                  "phone_number_country_code": number_summary['PhoneNumberCountryCode'],
                                  "phone_number_carrier" : phone_number_carrier,
                                  "error": str(e)
                              })
                  
                  return phone_numbers
                  
              except Exception as e:
                  print(f"Error listing phone numbers: {str(e)}")
                  return []

          """Categorize phone numbers by type"""
          def count_phone_numbers_by_type(connect_client, instance_id):
              """
              Count phone numbers by type using ListPhoneNumbersV2
              """
              
              # Initialize counters for all possible phone number types
              phone_type_counts = {
                  'TOLL_FREE': 0,
                  'DID': 0,
                  'UIFN': 0,
                  'SHARED': 0,
                  'THIRD_PARTY_TF': 0,
                  'THIRD_PARTY_DID': 0,
                  'SHORT_CODE': 0
              }
              
              # Additional tracking
              country_counts = Counter()
              status_counts = Counter()
              total_numbers = 0
              
              try:
                  # Use ListPhoneNumbersV2 for accurate type identification
                  paginator = connect_client.get_paginator('list_phone_numbers_v2')
                  
                  for page in paginator.paginate(InstanceId=instance_id):
                      for number_summary in page.get('ListPhoneNumbersSummaryList', []):
                          total_numbers += 1
                          
                          # Count by type
                          phone_type = number_summary.get('PhoneNumberType', 'UNKNOWN')
                          if phone_type in phone_type_counts:
                              phone_type_counts[phone_type] += 1
                          
                          # Count by country
                          country_code = number_summary.get('PhoneNumberCountryCode', 'UNKNOWN')
                          country_counts[country_code] += 1
                          
                          # Get status information if available
                          try:
                              detailed_info = connect_client.describe_phone_number(
                                  PhoneNumberId=number_summary['PhoneNumberId']
                              )
                              status = detailed_info['ClaimedPhoneNumberSummary'].get('PhoneNumberStatus', 'UNKNOWN')
                              status_counts[status] += 1
                          except Exception as e:
                              logger.error(f"Is this Error getting status for {number_summary['PhoneNumberId']}: {str(e)}")
                              status_counts['UNKNOWN'] += 1
                  
                  # Add additional information to the counts
                  phone_type_counts['_metadata'] = {
                      'total_numbers': total_numbers,
                      'country_distribution': dict(country_counts),
                      'status_distribution': dict(status_counts),
                      'countries_count': len(country_counts),
                      'most_common_country': country_counts.most_common(1)[0] if country_counts else None
                  }
                  
                  return phone_type_counts
                  
              except Exception as e:
                  logger.error(f"Error listing phone numbers: {str(e)}")
                  return phone_type_counts

          """Analyze Carrier Diversity"""
          def validate_phone_number_for_connect(phone_number, iso_country_code=None):
              """
              Validate a phone number using Amazon Pinpoint Phone Number Validation API
              to get service provider information for Amazon Connect phone numbers.
              
              Args:
                  phone_number (str): The phone number to validate (include country code)
                  iso_country_code (str, optional): Two-character ISO 3166-1 alpha-2 country code
              
              Returns:
                  dict: Phone number validation response with carrier and other details
              """
              try:
                  # Prepare the request
                  request_params = {
                      'NumberValidateRequest': {
                          'PhoneNumber': phone_number
                      }
                  }
                  
                  # Add country code if provided
                  if iso_country_code:
                      request_params['NumberValidateRequest']['IsoCountryCode'] = iso_country_code
                  
                  # Call the phone number validation API
                  response = pinpoint_client.phone_number_validate(**request_params)
                  
                  # Extract validation details
                  validation_result = response['NumberValidateResponse']
                  
                  # Format the result for easy consumption
                  result = {
                      'original_number': validation_result.get('OriginalPhoneNumber'),
                      'cleansed_e164': validation_result.get('CleansedPhoneNumberE164'),
                      'cleansed_national': validation_result.get('CleansedPhoneNumberNational'),
                      'carrier': validation_result.get('Carrier'),
                      'phone_type': validation_result.get('PhoneType'),
                      'phone_type_code': validation_result.get('PhoneTypeCode'),
                      'country': validation_result.get('Country'),
                      'country_code_iso2': validation_result.get('CountryCodeIso2'),
                      'country_code_numeric': validation_result.get('CountryCodeNumeric'),
                      'city': validation_result.get('City'),
                      'timezone': validation_result.get('Timezone'),
                      'zip_code': validation_result.get('ZipCode'),
                      'is_valid': validation_result.get('PhoneType') != 'INVALID'
                  }
                  
                  return result
                  
              except ClientError as e:
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  
                  return {
                      'error': True,
                      'error_code': error_code,
                      'error_message': error_message,
                      'original_number': phone_number
                  }
              except Exception as e:
                  return {
                      'error': True,
                      'error_message': str(e),
                      'original_number': phone_number
                  }

          """Get Amazon Connect CloudWatch Metrics"""
          def get_connect_metric_simple(instance_id, metric_name, days_back):
              """
              Simple function to get a specific Amazon Connect metric
              """
              
              end_time = datetime.utcnow()
              start_time = end_time - timedelta(days=days_back)
              
              try:
                  response = cloudwatch_client.get_metric_statistics(
                      Namespace='AWS/Connect',
                      MetricName=metric_name,
                      Dimensions=[
                          {'Name': 'InstanceId', 'Value': instance_id},
                          {'Name': 'MetricGroup', 'Value': 'VoiceCalls'}
                      ],
                      StartTime=start_time,
                      EndTime=end_time,
                      Period=3600,  # 1 hour
                      Statistics=['Sum', 'Average', 'Maximum']
                  )
                  
                  datapoints = response['Datapoints']
                  
                  if datapoints:
                      # Sort by timestamp
                      datapoints.sort(key=lambda x: x['Timestamp'])
                      
                      logger.debug(f"üìä {metric_name} (last {days_back} days):")
                      
                      if 'Sum' in datapoints[0]:
                          total = sum(dp.get('Sum', 0) for dp in datapoints)
                          logger.debug(f"   Total: {total:.0f}")
                      
                      if 'Average' in datapoints[0]:
                          avg_values = [dp.get('Average', 0) for dp in datapoints]
                          overall_avg = sum(avg_values) / len(avg_values)
                          logger.debug(f"   Average: {overall_avg:.2f}")
                      
                      if 'Maximum' in datapoints[0]:
                          max_values = [dp.get('Maximum', 0) for dp in datapoints]
                          peak = max(max_values)
                          logger.debug(f"   Peak: {peak:.0f}")
                      
                      return datapoints
                  else:
                      logger.debug(f"No data found for {metric_name}")
                      return []
                      
              except Exception as e:
                  logger.error(f"Error getting {metric_name}: {str(e)}")
                  return []

          """Get Amazon Connect Flows"""
          def get_contact_flows(instance_id):
              """Get all contact flows for the instance"""
              
              try:
                  contact_flows = {}
                  paginator = connect_client.get_paginator('list_contact_flows')
                  
                  for page in paginator.paginate(InstanceId=instance_id):
                      for flow in page['ContactFlowSummaryList']:
                          contact_flows[flow['Id']] = {
                              'name': flow['Name'],
                              'type': flow['ContactFlowType'],
                              'arn': flow['Arn']
                          }
                  
                  return contact_flows
                  
              except Exception as e:
                  logger.debug(f"Error getting contact flows: {str(e)}")
                  return {}

          """Log Insights Query"""
          def run_log_insights_query(logs_client, log_group, query, start_time, end_time):
              """Execute CloudWatch Log Insights query"""
              
              try:
                  # Start the query
                  response = logs_client.start_query(
                      logGroupName=log_group,
                      startTime=int(start_time.timestamp()),
                      endTime=int(end_time.timestamp()),
                      queryString=query
                  )
                  
                  query_id = response['queryId']
                  
                  # Wait for query to complete
                  max_attempts = 30
                  attempt = 0
                  
                  while attempt < max_attempts:
                      time.sleep(2)
                      
                      result = logs_client.get_query_results(queryId=query_id)
                      
                      if result['status'] == 'Complete':
                          return result['results']
                      elif result['status'] == 'Failed':
                          raise Exception(f"Query failed: {result.get('statistics', {})}")
                      
                      attempt += 1
                  
                  raise Exception("Query timeout")
                  
              except Exception as e:
                  logger.error(f"Error running query: {str(e)}")
                  return []

          """Contact Flow Errors"""
          def analyze_contact_flow_errors(logs_client, instance_id, start_time, end_time, contact_flows):
              """Analyze contact flow errors using CloudWatch Log Insights"""
                  
              # Query for all contact flow errors
              error_query = """
              fields @timestamp, ContactId, ContactFlowId, ContactFlowModuleType, LogLevel, Message, Parameters
              | filter LogLevel = "ERROR"
              | stats count() as ErrorCount by ContactFlowId, ContactFlowModuleType, Message
              | sort ErrorCount desc
              """
              
              try:
                  error_results = run_log_insights_query(logs_client, log_group, error_query, start_time, end_time)
                  
                  # Query for detailed error information
                  detailed_error_query = """
                  fields @timestamp, ContactId, ContactFlowId, ContactFlowModuleType, LogLevel, Message, Parameters
                  | filter LogLevel = "ERROR"
                  | sort @timestamp desc
                  | limit 100
                  """
                  
                  detailed_errors = run_log_insights_query(logs_client, log_group, detailed_error_query, start_time, end_time)
                  
                  # Process and categorize errors
                  processed_errors = process_error_results(error_results, detailed_errors, contact_flows)
                  
                  return processed_errors
                  
              except Exception as e:
                  logger.error(f"Error analyzing contact flow errors: {str(e)}")
                  return {}

          """Find contact flows where 'Set logging behavior' block is not enabled (set to TRUE)"""
          def find_flows_without_logging_enabled(instance_id):
              
              flows_without_logging = []
              
              try:
                  # Get all contact flows
                  paginator = connect_client.get_paginator('list_contact_flows')
                  page_iterator = paginator.paginate(InstanceId=instance_id)
                  
                  for page in page_iterator:
                      for flow_summary in page['ContactFlowSummaryList']:
                          flow_id = flow_summary['Id']
                          flow_name = flow_summary['Name']
                          flow_type = flow_summary['ContactFlowType']
                          
                          logger.debug(f"Analyzing flow: {flow_name} (ID: {flow_id})")

                          try:
                              # Get detailed flow information including content
                              flow_details = connect_client.describe_contact_flow(
                                  InstanceId=instance_id,
                                  ContactFlowId=flow_id
                              )
                              
                              # Parse the flow content (JSON string)
                              flow_content = json.loads(flow_details['ContactFlow']['Content'])

                              # Check if logging is enabled in this flow
                              logging_enabled = check_logging_behavior_in_flow(flow_content)
                              logger.debug(f"logging_enabled: {logging_enabled}")

                              if not logging_enabled:
                                  flows_without_logging.append({
                                      'FlowId': flow_id,
                                      'FlowName': flow_name,
                                      'FlowType': flow_type,
                                      'FlowArn': flow_summary.get('Arn', ''),
                                      'Status': flow_summary.get('ContactFlowStatus', ''),
                                      'State': flow_summary.get('ContactFlowState', '')
                                  })
                                  logger.debug(f"‚ùå Logging is not enabled for flow: {flow_name} (ID: {flow_id})")
                              else :
                                  logger.debug(f"‚úÖ Logging is enabled for flow: {flow_name} (ID: {flow_id})")
                                  
                          except Exception as e:
                              logger.error(f"Error analyzing flow {flow_name}: {str(e)}")
                              continue
                              
              except Exception as e:
                  logger.error(f"Error listing contact flows: {str(e)}")
                  return []
              
              return flows_without_logging

          """Check if the flow contains a 'Set logging behavior' block with logging enabled"""
          def check_logging_behavior_in_flow(flow_content):

              state = False

              # Look for actions in the flow content
              actions = flow_content.get('Actions', [])
              
              for action in actions:
                  # Check if this is a Set logging behavior block
                  action_type = action.get('Type', '')
                  if action_type == 'UpdateFlowLoggingBehavior':

                      # Check the parameters to see if logging is enabled
                      parameters = action.get('Parameters', {})
                      logging_behavior = parameters.get('FlowLoggingBehavior', '')
                      logger.debug(f"parameters: {parameters}")
                      logger.debug(f"logging_behavior: {logging_behavior}")

                      # If LoggingBehavior is set to 'Enable', then logging is enabled
                      if logging_behavior == 'Enabled':
                          state = True
                          logger.debug(f"action_type: {action_type}")
                          break  # Stop searching once we find a logging block that is enabled

              # If no SetLoggingBehavior block found or none are enabled
              return state
          """Main Handler"""
          def lambda_handler(event, context):
              try:
                  mystring = ""
                  combined_string = ""
                  cfs_limit=""
                  rps_limit = ""
                  queues_limit = ""
                  sec_profiles_limit = ""
                  users_limit = ""
                  bots_limit = ""
                  days_back = 14
                  metric_name = ""
                  html_content = ""
                  hasConnectReplica = "no"

                  s3_reporting_bucket = os.environ.get('S3_REPORTING_BUCKET')
                  connect_cloudwatch_log_group = os.environ.get('CONNECT_CW_LOG_GROUP')

                  logger.info(f"Execute Automated Amazon Connect Operational Review: {datetime_string}")
                  lambda_exec_start_time = time.time()

                  # Far back to evaluate logs
                  days_back = 14
                  end_time = datetime.utcnow()
                  start_time = end_time - timedelta(days=days_back)

                  # Parse Amazon connect instance info from environment variables
                  parsed = parse_connect_instance_arn(os.environ.get('CONNECT_INSTANCE_ARN'))
                  instance_id = str(parsed['instance_id'])
                  aws_region = str(parsed['aws_region'])
                  account_id = str(parsed['account_id'])

                  logger.info (f"Instance Details parsed from env variables: {instance_id}, AWS Region: {aws_region}, Account ID: {account_id}")

                  # Current Quota Limits
                  quotas = get_connect_service_quotas()
                  logger.debug(f"Found {len(quotas)} Amazon Connect service quotas:\n")

                  for quota in quotas:
                     
                      if quota['QuotaName'] == "Contact flows per instance":
                          cfs_string = "Contact flows per instance - Current Limit : " + str(quota['Value'])  + ". "
                          cfs_limit = str(quota['Value'])
                          logger.debug(f"{cfs_string}")

                      elif quota['QuotaName'] == "Routing profiles per instance":
                          rps_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Queues per instance":
                          queues_limit = str(quota['Value'])
                      
                      elif quota['QuotaName'] == "Security profiles per instance":
                          sec_profiles_limit = str(quota['Value'])
                      
                      elif quota['QuotaName'] == "Users per instance":
                          users_limit = str(quota['Value'])
                      
                      elif quota['QuotaName'] == "Amazon Lex bots per instance":
                          botsv1_limit = str(quota['Value'])
                      
                      elif quota['QuotaName'] == "Phone numbers per instance":
                          phone_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Amazon Lex V2 bot aliases per instance":
                          botsv2_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Quick connects per instance":
                          qc_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Hours of operation per instance":
                          hrs_operation_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Users per instance":
                          users_limit = str(quota['Value'])

                      elif quota['QuotaName'] == "Amazon Lex bots per instance":
                          bots_limit = str(quota['Value'])

                      else:
                          quota_name = quota['QuotaName']
                          quota_value = quota['Value']
                          
                  if not instance_id:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'Connect Instance ID is required'})
                      }

                  #Describe Instance and create the intial html output
                  html_output = describe_connect_to_html(instance_id)
                  

                  html_output += """<h2>Resilience</h2>
                                      <p>Within each AWS Region Amazon Connect instance is created with a minimum of 3 AZs. When you create an Amazon Connect instance, that instance is propagated across those AZs in an active-active-active configuration. If there is a failure in one AZ, that node is taken out of rotation without impacting production. This architecture allows you to perform maintenance, release new features, and expand infrastructure without requiring any downtime.
                                      Refer <a href="https://docs.aws.amazon.com/connect/latest/adminguide/disaster-recovery-resiliency.html" target="_blank"> documentation </a> for more information</p>"""

                  #ACGR Recommendation
                  if hasConnectReplica == "no":
                       html_output += """<h3>Amazon Connect Global Resiliency</h3>
                              <h4>Recommendation</h4>
                              <ul> No replica configured.
                                  Consider Amazon Connect Global Resiliency (ACGR) for region resiliency requirements. ACGR provides customers with geographic telephony redundancy, offering a flexible solution to distribute inbound voice traffic and agents across linked instances with the same reserved capacity limit, in another Region in the event of unplanned Region outages or disruptions or other requirements.
                                  Refer <a href="https://docs.aws.amazon.com/connect/latest/adminguide/disaster-recovery-resiliency.html" target="_blank"> documentation </a> for more information 
                              </ul>
                              </div>"""

                  #Carrier Diversity      
                  html_output += f"""</div>
                      <div class="section">
                      <h3>Carrier diversity with Amazon Connect phone numbers</h3>
                      <table style="width: 80%">
                      <tr><th>Country Code | Phone Carrier</th><th>Count</th><th>Phone Number List</th></tr>"""
                  # Get all phone numbers for the instance
                  phone_numbers = get_phone_numbers_with_basic_details(connect_client, instance_id)
                  logger.debug(f"Phone numbers: {phone_numbers}")

                  multi_groups = segregate_by_multiple_criteria(phone_numbers, ["phone_number_country_code", "phone_number_carrier"])
                  logger.debug("By country code and carrier:")
                  for group_key, ph_nos in multi_groups.items():
                      logger.debug(f"{group_key}:  Count - {len(ph_nos)}, List - {[ph['phone_number'] for ph in ph_nos]}")
                      html_output += f"""
                          <tr><th>{escape(group_key)}</th><td>{escape(str(len(ph_nos)))}</td><td>{[ph['phone_number'] for ph in ph_nos]}</td></tr>
                          """  
                  html_output += """</table>"""                  
                  if len(phone_numbers) > 1:
                      html_output += f"""<h4>Recommendation</h4>
                                  <ul> In the US, you should use Amazon Connect telephony services for US toll-free numbers, allowing you to route toll-free traffic across multiple suppliers in an active-active fashion at no additional charge. In situations where you are forwarding inbound traffic to an Amazon Connect phone number, you should request redundant DID or Toll-Free numbers across multiple telephony providers. If you are claiming or porting multiple DID or Toll-Free numbers outside of the US, you should request that those numbers be claimed or ported to a variety of telephony providers for increased resiliency.
                                  Refer <a href="https://docs.aws.amazon.com/connect/latest/adminguide/operational-excellence.html#prepare" target="_blank"> documentation </a> for more information</ul>"""
            

                  #Get Usage%
                  cfs_percentage = current_utilization(instance_id, "ContactFlows") / int(float(cfs_limit)) * 100
                  rps_percentage = current_utilization(instance_id, "RoutingProfiles") / int(float(rps_limit)) * 100
                  queues_percentage = current_utilization(instance_id, "Queues") / int(float(queues_limit)) * 100
                  sec_profiles_percentage = current_utilization(instance_id, "SecurityProfiles") / int(float(sec_profiles_limit)) * 100
                  users_percentage = current_utilization(instance_id, "Users") / int(float(users_limit)) * 100
                  botsv1_percentage = current_utilization(instance_id, "LexBotsV1") / int(float(botsv1_limit)) * 100
                  botsv2_percentage = current_utilization(instance_id, "LexBotsV2") / int(float(botsv2_limit)) * 100
                  phone_percentage = current_utilization(instance_id, "PhoneNumbers") / int(float(phone_limit)) * 100
                  qc_percentage = current_utilization(instance_id, "QuickConnects") / int(float(qc_limit)) * 100
                  hrs_operation_percentage = current_utilization(instance_id, "HoursOfOperation") / int(float(hrs_operation_limit)) * 100
                  users_percentage = current_utilization(instance_id, "Users") / int(float(users_limit)) * 100

                  #HTML Output - Connect Usage Vs Limits
                  html_output += f"""
                      <html>
                      <body>
                      <div class="section">
                          <br><h2>Operational Excellence</h2>
                          <h3>Capacity Analysis: Current Instance Usage Vs Limit</h3>
                          <table style="width: 50%">
                              <tr><th></th><th>Current Use</th><th>Quota Limit</th><th>Usage %</th></tr>
                              <tr><th>Contact Flows per instance</th><td>{escape(str(current_utilization(instance_id, "ContactFlows")))}</td><td text-align: center;>{escape(cfs_limit)}</td></td><td style="background-color: {get_color_by_percentage(cfs_percentage)} ;">{escape(str(cfs_percentage))}%</td></tr>
                              <tr><th>Queues per instance</th><td>{escape(str(current_utilization(instance_id, "Queues")))}</td><td text-align: center;>{escape(queues_limit)}</td></td><td style="background-color: {get_color_by_percentage(queues_percentage)} ;">{escape(str(queues_percentage))}%</td></tr>
                              <tr><th>Routing Profiles per instance</th><td>{escape(str(current_utilization(instance_id, "RoutingProfiles")))}</td><td text-align: center;>{escape(rps_limit)}</td></td><td style="background-color: {get_color_by_percentage(rps_percentage)} ;">{escape(str(rps_percentage))}%</td></tr>
                              <tr><th>Security Profiles per instance</th><td>{escape(str(current_utilization(instance_id, "SecurityProfiles")))}</td><td>{escape(sec_profiles_limit)}</td></td><td style="background-color: {get_color_by_percentage(sec_profiles_percentage)} ;">{escape(str(sec_profiles_percentage))}%</td></tr>
                              <tr><th>Users per instance</th><td>{escape(str(current_utilization(instance_id, "Users")))}</td><td>{escape(users_limit)}</td></td><td style="background-color: {get_color_by_percentage(users_percentage)} ;">{escape(str(users_percentage))}%</td></tr>
                              <tr><th>Lex Bots V1 per instance</th><td>{escape(str(current_utilization(instance_id, "LexBotsV1")))}</td><td>{escape(botsv1_limit)}</td></td><td style="background-color: {get_color_by_percentage(botsv1_percentage)} ;">{escape(str(botsv1_percentage))}%</td></tr>
                              <tr><th>Lex Bots V2 per instance</th><td>{escape(str(current_utilization(instance_id, "LexBotsV2")))}</td><td>{escape(botsv2_limit)}</td></td><td style="background-color: {get_color_by_percentage(botsv2_percentage)} ;">{escape(str(botsv2_percentage))}%</td></tr>
                              <tr><th>PhoneNumbers per instance</th><td>{escape(str(current_utilization(instance_id, "PhoneNumbers")))}</td><td>{escape(phone_limit)}</td><td style="background-color: {get_color_by_percentage(phone_percentage)} ;">{escape(str(phone_percentage))}%</td></tr>
                              <tr><th>QuickConnects per instance</th><td>{escape(str(current_utilization(instance_id, "QuickConnects")))}</td><td>{escape(qc_limit)}</td></td><td style="background-color: {get_color_by_percentage(qc_percentage)} ;">{escape(str(qc_percentage))}%</td></tr>
                              <tr><th>HoursOfOperation per instance</th><td>{escape(str(current_utilization(instance_id, "HoursOfOperation")))}</td><td>{escape(hrs_operation_limit)}</td></td><td style="background-color: {get_color_by_percentage(hrs_operation_percentage)} ;">{escape(str(hrs_operation_percentage))}%</td></tr>
                         </table>
                      </div>
                      <h4>Recommendations</h4>
                      <ul>
                          <li><span style="background-color: {get_color_by_percentage(50)};">Green</span> : The current service usage is well within the allocated limit.</li>
                          <li><span style="background-color: {get_color_by_percentage(90)};">Orange</span>: Usage is nearing the limit, and the status warrants monitoring or a potential increase to prevent it from turning red.</li>
                          <li><span style="background-color: {get_color_by_percentage(100)};">Red</span>: The quota has been almost reached or exceeded, and the service may be at risk or already interrupted. Consider requesting quota increases via <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html" target="_blank">AWS Service Quota</a>.</li> 
                      </ul>
                      </html>
                      </body>
                      """

                  html_output += f"""
                      <html>
                      <body>
                      <div class="section">
                      <br><h3>Contact Flows missing logging</h3>
                      Analyzed {escape(str(current_utilization(instance_id, "ContactFlows")))} contact flows....<br>
                      """

                  flows_without_logging = find_flows_without_logging_enabled(instance_id)
                  
                  if flows_without_logging.__len__() == 0:
                      html_output += f"""<br> No contact flows without logging enabled found."""
                  else:
                      html_output += f"""
                             <br>{flows_without_logging.__len__()} contact flows without logging enabled found.<br><br>
                              <table style="width: 80%">
                                      <tr><th>Flow Name</th><th>Flow ID</th><th>Flow Type</th><th>Status</th><th>State</th></tr>"""
                      
                      for flow in flows_without_logging:
                          html_output += f"""
                                      <tr><td>{flow['FlowName']}</td><td>{flow['FlowId']}</td><td>{flow['FlowType']}</td><td>{flow['Status']}</td><td>{flow['State']}</td></tr>
                              """
                      html_output += f"""</table>
                      <h4>Recommendations</h4>
                      <ul>
                          <li>Use a Set logging behavior block to enable or disable logging for segments of the flow where sensitive information is collected and can't be stored in CloudWatch.</li>
                          <li>Learn more about contact flow <a href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-flow-logs.html" target="_blank">logging</a>.</li>
                      </ul>
                      """
            
                  html_output += f"""
                      </div><div class="section">
                      <br><h3>Concurrent Calls Analysis</h3>
                      """
                  html_output += summarize_concurrent_calls(instance_id, days_back)

                  html_output += f"""</div>
                      <div class="section">
                      <br><h3>Missed Calls Analysis</h3>
                      """
                  html_output += summarize_missed_calls(instance_id, days_back)

                  html_output += f"""</div>
                      <div class="section">
                      <br><h3>Throttled Calls Analysis</h3>
                      """
                  html_output += summarize_throttled_calls(instance_id, days_back)

                  html_output += f"""</div>
                      <div class="section">
                      <br><h3>Amazon Connect API Throttling (Account level)</h3>
                      """
                  html_output += summarize_amazon_api_throttles(instance_id, account_id, days_back, aws_region)

                  #Phone Number Analysis
                  phone_type_counts = count_phone_numbers_by_type(connect_client, instance_id)
                  logger.debug(f"Phone type counts: {phone_type_counts}")

                  metadata = phone_type_counts.get('_metadata', {})
                  total_numbers = metadata.get('total_numbers', 0)

                  html_output += f"""
                      <h2>Cost Considerations</h2>
                      <h3>Phone Number Analysis</h3>
                      Analyzed {escape(str(total_numbers))} phone numbers....<br>
                      """

                  if total_numbers == 0:
                       html_output += "No phone numbers analyzed."

                  else :    # Check for toll-free dominance
                      toll_free_count = phone_type_counts.get('TOLL_FREE', 0)
                      if toll_free_count > 0:
                          toll_free_percentage = (toll_free_count / total_numbers) * 100
                          if toll_free_percentage > 70:
                              html_output += (f"High toll-free usage: {toll_free_percentage:.1f}% of numbers are toll-free (potential cost optimization opportunity)")
                          elif toll_free_percentage < 20:
                              html_output += (f"<br>Low toll-free usage: Only {toll_free_percentage:.1f}% are toll-free (consider customer accessibility)")
                      
                      # Check for DID usage
                      did_count = phone_type_counts.get('DID', 0)
                      if did_count > 0:
                          did_percentage = (did_count / total_numbers) * 100
                          html_output += (f"<br>DID numbers provide local presence: {did_percentage:.1f}% of total numbers")
                      
                      # Check for international presence
                      metadata = phone_type_counts.get('_metadata', {})
                      countries_count = metadata.get('countries_count', 0)
                      if countries_count > 1:
                          html_output += (f"<br>International presence: Numbers in {countries_count} countries")
                      
                      # Check for special types
                      uifn_count = phone_type_counts.get('UIFN', 0)
                      short_code_count = phone_type_counts.get('SHORT_CODE', 0)
                      
                      if uifn_count > 0:
                          html_output += (f"<br>Global accessibility: {uifn_count} UIFN numbers for international toll-free access")
                      
                      if short_code_count > 0:
                          html_output += (f"<br>SMS capability: {short_code_count} short codes for messaging services")    

                      html_output += f"""
                          <h4>Recommendations</h4>"""

                      if phone_type_counts.get('TOLL_FREE', 0) == 0:
                          html_output += f"""    
                          <ul>
                              <li>Consider using toll-free numbers for international toll-free access.</li>
                              <li>Learn more about <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ag-overview-numbers.html" target="_blank">phone number types</a>.</li>
                          </ul>
                          """
                      if phone_type_counts.get('TOLL_FREE', 0) < phone_type_counts.get('DID', 0):
                          html_output += f"""
                          <ul>
                              <li>In the US, use toll-free phone numbers wherever possible to load balance across multiple carriers for additional route and carrier redundancy.</li>
                              <li>In situations where you use DIDs, load balance across numbers from multiple carriers, when possible, to increase reliability.</li>
                              <li>This level of service does come at an additional cost.</li>
                          </ul>
                          """

                      else :
                          html_output += f"""
                          <ul>
                          Though Toll free numbers provide additional resiliency, it comes with additional cost when compared with DIDs. Apply your workload's
                          availability and resiliency requirements in choosing right telephony numbers. Refer <a href="https://docs.aws.amazon.com/connect/latest/adminguide/ag-overview-numbers.html" target="_blank">documentation</a> for additional details on DIDs and TFNs in
                          Amazon Connect. 
                          </ul>
                          """


                  html_output += f"""</div>
                      </html>
                      </body>
                      """

                   # Get key metrics
                  get_connect_metric_simple(instance_id, 'CallsPerInterval', days_back)
                  get_connect_metric_simple(instance_id, 'ConcurrentCalls', days_back)
                  get_connect_metric_simple(instance_id, 'MissedCalls', days_back)
                  get_connect_metric_simple(instance_id, 'QueueSize', days_back)

                  # Upload to S3
                  upload_string_to_s3(html_output, s3_reporting_bucket, 'my-connect-review.html','text/html') 
                  
                  lambda_exec_end_time = time.time()
                  duration = lambda_exec_end_time - lambda_exec_start_time
                  print(f"Lambda execution time: {duration}")

                  return {
                          'statusCode': 200,
                          'body': json.dumps({'success': f'Amazon Connect Ops Review document succesfully generated. Execution duration: {duration} seconds")'})
                      }
                  
              except Exception as e:
                  exc_type, exc_obj, exc_tb = sys.exc_info()
                  lineno = exc_tb.tb_lineno
                  (f"AWS Client Error: {e}")
                  logger.error(f"An error occurred: {e}")
                  logger.error(f"Error on line: {lineno}")
                  logger.error(f"Traceback: {traceback.print_exc()}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': 'AWS API Error',
                          'line': lineno,
                          'message': str(traceback.print_exc())
                      })
                  }
        
  # CloudWatch Log Group for Lambda
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: "/aws/lambda/amazonConnectOperationalReview-auto"
      RetentionInDays: 30

Outputs:
  LambdaFunctionArn:
    Description: 'ARN of the Lambda function'
    Value: !GetAtt LambdaFunctionAmazonConnectOperationalReviewauto.Arn
  
  LambdaFunctionName:
    Description: 'Name of the Lambda function'
    Value: !Ref LambdaFunctionAmazonConnectOperationalReviewauto
